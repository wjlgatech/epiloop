#========================================================
# REAL-WORLD BENCHMARK TASK 010
# Tier: MESO (Medium Feature)
# Source: Infrastructure/DevOps pattern
#========================================================

id: TASK-010
name: "Rate Limiting Middleware Implementation"
tier: meso
source_project: null
difficulty: 3  # 1-5 scale
estimated_time_human_minutes: 70

#--------------------------------------------------------
# PROBLEM DESCRIPTION
#--------------------------------------------------------
description: |
  **Requirement**: Protect API from abuse with rate limiting.

  **Problem**: API endpoints are being hammered:
  - 10,000+ requests/second from single IP
  - Causing service degradation for legitimate users
  - No rate limiting currently in place

  **Task**: Implement rate limiting middleware that:
  1. Limits requests per IP (100 requests/minute)
  2. Returns 429 (Too Many Requests) when limit exceeded
  3. Includes rate limit headers in response
  4. Uses sliding window algorithm
  5. Stores state in Redis/memory
  6. Configurable limits per endpoint

#--------------------------------------------------------
# ACCEPTANCE CRITERIA
#--------------------------------------------------------
acceptance_criteria:
  - id: AC1
    description: "Implements rate limiting decorator/middleware"
    weight: 0.25
    validation_method: "grep"
    validation_script: |
      grep -iE "(@.*limit|rate.*limit|class.*RateLimit)" . -r

  - id: AC2
    description: "Tracks requests per IP address"
    weight: 0.20
    validation_method: "grep"
    validation_script: |
      grep -E "(request\.remote_addr|get_client_ip|X-Forwarded-For)" . -r

  - id: AC3
    description: "Returns 429 status when limit exceeded"
    weight: 0.20
    validation_method: "grep"
    validation_script: |
      grep -E "(429|Too Many Requests|rate.*exceed)" . -r

  - id: AC4
    description: "Adds rate limit headers (X-RateLimit-*)"
    weight: 0.20
    validation_method: "grep"
    validation_script: |
      grep -E "(X-RateLimit|RateLimit-Limit|RateLimit-Remaining)" . -r

  - id: AC5
    description: "Uses time-based sliding window or token bucket"
    weight: 0.15
    validation_method: "grep"
    validation_script: |
      grep -E "(time\(\)|timestamp|window|bucket|expire)" . -r

#--------------------------------------------------------
# IMPLEMENTATION HINTS
#--------------------------------------------------------
implementation_hints:
  approach: |
    **Using Flask + Redis**:
    ```python
    from flask import request, jsonify
    from functools import wraps
    import redis
    import time

    redis_client = redis.Redis()

    def rate_limit(max_requests=100, window_seconds=60):
        def decorator(f):
            @wraps(f)
            def wrapped(*args, **kwargs):
                ip = request.remote_addr
                key = f"rate_limit:{ip}"

                # Get current request count
                count = redis_client.get(key)

                if count is None:
                    # First request in window
                    redis_client.setex(key, window_seconds, 1)
                    return f(*args, **kwargs)

                count = int(count)

                if count >= max_requests:
                    # Rate limit exceeded
                    return jsonify({
                        "error": "Rate limit exceeded"
                    }), 429

                # Increment counter
                redis_client.incr(key)

                # Add headers
                response = f(*args, **kwargs)
                response.headers['X-RateLimit-Limit'] = max_requests
                response.headers['X-RateLimit-Remaining'] = max_requests - count - 1

                return response
            return wrapped
        return decorator
    ```

  alternative_approaches:
    - "In-memory dict with timestamps (for single-server)"
    - "Token bucket algorithm for smoother rate limiting"
    - "Distributed rate limiter with Redis sorted sets"

#--------------------------------------------------------
# TEST DATA
#--------------------------------------------------------
test_data:
  test_scenarios:
    - name: "Under limit"
      requests: 50
      expected_status: 200

    - name: "At limit"
      requests: 100
      expected_status: 200

    - name: "Over limit"
      requests: 101
      expected_status: 429

    - name: "After window expires"
      requests: 100
      wait_seconds: 61
      then_requests: 1
      expected_status: 200

#--------------------------------------------------------
# SUCCESS CRITERIA SUMMARY
#--------------------------------------------------------
success_definition: |
  Task is complete when:
  1. ✓ Rate limiting middleware created
  2. ✓ Tracks requests by IP
  3. ✓ Returns 429 after limit exceeded
  4. ✓ Includes X-RateLimit-* headers
  5. ✓ Uses sliding window or token bucket
  6. ✓ Configurable limits (100/min default)
  7. ✓ Tests verify rate limiting works

#--------------------------------------------------------
# IMPLEMENTATION CONSIDERATIONS
#--------------------------------------------------------
considerations:
  performance:
    - "Use Redis for distributed systems"
    - "Avoid DB queries in every request"
    - "Consider connection pooling for Redis"

  security:
    - "Handle X-Forwarded-For spoofing"
    - "Rate limit by user ID for authenticated requests"
    - "Different limits for different endpoints"

  edge_cases:
    - "Clock synchronization in distributed systems"
    - "Race conditions in concurrent requests"
    - "Redis unavailability (fallback to allow/deny all?)"

#--------------------------------------------------------
# EXAMPLE USAGE
#--------------------------------------------------------
example_usage: |
  # Apply to specific endpoint
  @app.route('/api/search')
  @rate_limit(max_requests=100, window_seconds=60)
  def search():
      return {"results": [...]}

  # Apply globally
  app.before_request(rate_limit(max_requests=100))

  # Different limits for different endpoints
  @app.route('/api/expensive')
  @rate_limit(max_requests=10, window_seconds=60)
  def expensive_operation():
      return perform_expensive_task()

#--------------------------------------------------------
# METADATA
#--------------------------------------------------------
metadata:
  tags: ["rate-limiting", "middleware", "infrastructure", "redis"]
  estimated_impact: "high"
  complexity_signals:
    - "Distributed state management"
    - "Time-based algorithms"
    - "HTTP middleware"
    - "Redis integration"
