#!/bin/bash
#
# claude-loop.sh - Autonomous Claude Code Loop for Feature Implementation
#
# A native Claude Code equivalent of Ralph that runs Claude in repeated
# iterations until all PRD user stories are complete.
#
# SELF-SUFFICIENT: Bundled core agents work out of the box.
# Use --agents-dir to add external specialists on top of bundled agents.
#
# Usage:
#   ./claude-loop.sh [options]
#
# Options:
#   -m, --max-iterations N   Maximum iterations (default: 10)
#   -p, --prd FILE|DIR|ID   Path to prd.json, PRD directory, or PRD ID
#                           (default: auto-detect from prds/active/ or ./prd.json)
#   -a, --agents-dir DIR    Optional: external agents for more specialists
#   -d, --delay N           Delay between iterations in seconds (default: 2)
#   -v, --verbose           Enable verbose output
#   --no-agents             Disable agent integration
#   --resume                Resume from last checkpoint if available
#   -h, --help              Show this help message
#
# Requirements:
#   - claude CLI installed and authenticated
#   - jq for JSON parsing
#   - git repository initialized
#

set -euo pipefail

# ============================================================================
# Configuration
# ============================================================================

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
MAX_ITERATIONS=10
PRD_FILE="./prd.json"
PRD_DIR=""  # Directory containing prd.json (for prds/active/* style PRDs)
PROGRESS_FILE=""  # Path to progress.txt (defaults to PRD_DIR/progress.txt or ./progress.txt)
DELAY_SECONDS=2
VERBOSE=false
PROMPT_FILE="${SCRIPT_DIR}/prompt.md"
LAST_BRANCH_FILE="./.last-branch"
ARCHIVE_DIR="./archive"
COMPLETION_SIGNAL="<loop>COMPLETE</loop>"

# Agent Integration (Hybrid Approach)
# Bundled agents are always available; external agents-dir adds specialists
BUNDLED_AGENTS_DIR="${SCRIPT_DIR}/agents"
AGENTS_DIR=""  # Optional: external agents directory for additional specialists
AGENTS_ENABLED=true
AGENT_REGISTRY="${SCRIPT_DIR}/lib/agent-registry.sh"
MAX_AGENTS_PER_ITERATION=2
MAX_TOKENS_PER_AGENT=1000
ENABLED_TIERS="1,2"

# Execution Logging
EXECUTION_LOGGER="${SCRIPT_DIR}/lib/execution-logger.sh"
EXECUTION_LOGGING_ENABLED=true

# Experience Augmentation
PROMPT_AUGMENTER="${SCRIPT_DIR}/lib/prompt-augmenter.py"
EXPERIENCE_AUGMENTATION_ENABLED=true
MIN_HELPFUL_RATE=0.30
MAX_EXPERIENCES=3

# Unity Automation Mode
UNITY_MODE=false
UNITY_ORCHESTRATOR="${SCRIPT_DIR}/agents/computer_use/orchestrator.py"

# Checkpoint/Resume Mode
RESUME_MODE=false
RESUME_FROM_SESSION=""  # Specific session ID to resume from
CHECKPOINT_DIR="./.claude-loop/checkpoints"

# Session State Management (INV-007)
SESSION_STATE_SCRIPT="${SCRIPT_DIR}/lib/session-state.sh"
SESSION_STATE_ENABLED=true

# Improvement Management
IMPROVEMENT_MANAGER="${SCRIPT_DIR}/lib/improvement-manager.sh"
IMPROVEMENT_VALIDATOR="${SCRIPT_DIR}/lib/improvement-validator.py"
IMPROVEMENT_MODE=""  # list, review, approve, reject, execute, validate, rollback
IMPROVEMENT_TARGET=""  # PRD name for operations
IMPROVEMENT_NOTES=""  # Notes for approve
IMPROVEMENT_REASON=""  # Reason for reject/rollback
IMPROVEMENT_VALIDATE=false  # Run validation before execution
IMPROVEMENT_FORCE=false  # Force past validation failures
IMPROVEMENT_DRY_RUN=false  # Dry run for rollback

# Gap Analysis Daemon
GAP_ANALYSIS_DAEMON="${SCRIPT_DIR}/lib/gap-analysis-daemon.sh"
DAEMON_MODE=""  # start, stop, status

# Autonomous Mode

# Parallel PRD Execution Management (handles multiple PRDs with different branches)
PARALLEL_PRD_MANAGER="${SCRIPT_DIR}/lib/parallel-prd-manager.sh"
PARALLEL_PRD_ENABLED=true
FORCE_SEQUENTIAL=false
WORKTREE_PATH="NONE"
LOCK_FILE=""

AUTONOMOUS_GATE="${SCRIPT_DIR}/lib/autonomous-gate.py"
AUTONOMOUS_MODE=false
DISABLE_AUTONOMOUS=false

# Multi-LLM Review Integration (LLM-007)
REVIEW_PANEL_SCRIPT="${SCRIPT_DIR}/lib/review_panel.py"
REVIEW_ENABLED=false
REVIEW_PROVIDERS=""  # Empty = all configured providers
REVIEW_THRESHOLD=7   # Minimum consensus score (1-10)
MAX_REVIEW_CYCLES=2  # Maximum review-fix cycles per story

# Full Provider Replacement Mode (LLM-013)
AGENT_RUNTIME="${SCRIPT_DIR}/lib/agent_runtime.py"
PRIMARY_PROVIDER="claude"  # claude, openai, gemini, deepseek
PROVIDER_MODELS=""  # Optional: model override (e.g., gpt-4o, gemini-2.0-flash)

# Single-Command Entry Point (INV-008)
PRD_GENERATOR="${SCRIPT_DIR}/lib/prd-from-description.py"
FEATURE_DESCRIPTION=""  # Feature description for auto-PRD generation
AUTO_GENERATE_PRD=false

# Progress Dashboard (INV-006)
PROGRESS_DASHBOARD="${SCRIPT_DIR}/lib/progress-dashboard.py"
PROGRESS_DASHBOARD_ENABLED=true
DASHBOARD_COMPACT=false  # Use compact single-line mode

# Quality Gates (INV-009)
QUALITY_GATES_SCRIPT="${SCRIPT_DIR}/lib/quality-gates.py"
QUALITY_GATES_ENABLED=true
CURRENT_COMPLEXITY_LEVEL=""  # Cached complexity level

# Completion Summary (INV-010)
COMPLETION_SUMMARY_SCRIPT="${SCRIPT_DIR}/lib/completion-summary.py"
COMPLETION_SUMMARY_ENABLED=true

# Solutioning Generator (INV-004, integrated in INV-011)
SOLUTIONING_GENERATOR="${SCRIPT_DIR}/lib/solutioning-generator.py"
SOLUTIONING_ENABLED=true  # Auto-generate architecture.md and ADRs for Level >= 3

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
NC='\033[0m' # No Color

# ============================================================================
# Helper Functions
# ============================================================================

log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

log_iteration() {
    echo -e "${CYAN}[ITERATION $1/$MAX_ITERATIONS]${NC} $2"
}

log_agent() {
    echo -e "${MAGENTA}[AGENT]${NC} $1"
}

log_debug() {
    if $VERBOSE; then
        echo -e "${BLUE}[DEBUG]${NC} $1"
    fi
}

# Display progress dashboard (INV-006)
# Usage: display_progress_dashboard [--current-story STORY_ID]
display_progress_dashboard() {
    if ! $PROGRESS_DASHBOARD_ENABLED; then
        return 0
    fi

    if [ ! -f "$PROGRESS_DASHBOARD" ]; then
        log_debug "Progress dashboard not found: $PROGRESS_DASHBOARD"
        return 0
    fi

    local current_story=""
    local compact_flag=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --current-story)
                current_story="$2"
                shift 2
                ;;
            *)
                shift
                ;;
        esac
    done

    # Build command arguments
    local args="--prd $PRD_FILE"
    if [ -n "$current_story" ]; then
        args="$args --current-story $current_story"
    fi
    if $DASHBOARD_COMPACT; then
        args="$args --compact"
    fi

    # Run the dashboard
    python3 "$PROGRESS_DASHBOARD" $args 2>/dev/null || true
}

# Display compact progress (single line, for between iterations)
display_progress_compact() {
    if ! $PROGRESS_DASHBOARD_ENABLED; then
        return 0
    fi

    if [ ! -f "$PROGRESS_DASHBOARD" ]; then
        return 0
    fi

    local current_story="${1:-}"
    local args="--prd $PRD_FILE --compact"
    if [ -n "$current_story" ]; then
        args="$args --current-story $current_story"
    fi

    python3 "$PROGRESS_DASHBOARD" $args 2>/dev/null || true
}

show_help() {
    cat << EOF
claude-loop - Autonomous Claude Code Loop for Feature Implementation

USAGE:
    ./claude-loop.sh [OPTIONS]
    ./claude-loop.sh "feature description"

SINGLE-COMMAND ENTRY (INV-008):
    Start claude-loop with just a feature description. No PRD required!

    ./claude-loop.sh "Add user authentication with OAuth"
    ./claude-loop.sh "Create a dark mode toggle for settings"

    This will:
    1. Auto-generate a PRD from your description
    2. Auto-detect complexity level (0-4)
    3. Auto-select track (quick/standard/enterprise)
    4. Auto-select phases (analysis/planning/solutioning/implementation)
    5. Show all auto-detected settings before starting
    6. Begin autonomous implementation

OPTIONS:
    -m, --max-iterations N   Maximum number of iterations (default: 10)
    -p, --prd FILE|DIR|ID   Path to prd.json, PRD directory, or PRD ID
                            Accepts: prds/active/my-feature/prd.json, prds/active/my-feature/,
                            DOC-001, or ./prd.json. Auto-detects if only one active PRD exists.
    -a, --agents-dir DIR    Path to claude-agents directory for expertise
    -d, --delay N           Delay between iterations in seconds (default: 2)
    -v, --verbose           Enable verbose output
    --no-agents             Disable agent integration
    --no-experience         Disable experience augmentation
    --no-dashboard          Disable progress dashboard display
    --compact-dashboard     Use compact single-line progress display
    --max-agents N          Max agents per iteration (default: 2)
    --agent-tiers TIERS     Enabled tiers, comma-separated (default: 1,2)
    --unity                 Enable Unity automation mode (Quest 3 XR development)
    --resume                Resume from last session if available
    --resume-from <id>      Resume from specific session ID
    --list-sessions         List all available sessions
    --no-session            Disable session state auto-save
    -h, --help              Show this help message

IMPROVEMENT MANAGEMENT:
    --list-improvements     List all improvement PRDs with status
    --review-improvement <prd_name>
                           Show details of a specific improvement PRD
    --approve-improvement <prd_name> [--notes "..."]
                           Approve an improvement PRD for implementation
    --reject-improvement <prd_name> --reason "..."
                           Reject an improvement PRD with feedback
    --validate-improvement <prd_name> [--force]
                           Validate a PRD before deployment
    --execute-improvement <prd_name> [--validate] [--force]
                           Run an approved improvement PRD with claude-loop
                           --validate: run validation before execution
                           --force: bypass validation blocking conditions
    --rollback-improvement <prd_name> [--reason "..."] [--dry-run]
                           Rollback an improvement that caused regressions
                           --reason: specify reason for rollback
                           --dry-run: show what would happen without changes
    --improvement-history   Show improvement history with outcomes

GAP ANALYSIS DAEMON:
    --start-daemon          Start the background gap analysis daemon
    --stop-daemon           Stop the running daemon
    --daemon-status         Show daemon status

AUTONOMOUS MODE:
    --autonomous            Enable autonomous mode for daemon (auto-approve low-risk improvements)
    --disable-autonomous    Disable autonomous mode (revert to human-approval)
    --autonomous-status     Show autonomous mode gate status

MULTI-LLM REVIEW:
    --enable-review         Enable multi-LLM review panel after story completion
    --reviewers <list>      Comma-separated list of providers (default: all configured)
                           Example: --reviewers openai,gemini,deepseek
    --review-threshold N    Minimum consensus score to pass (1-10, default: 7)
    --max-review-cycles N   Maximum review-fix cycles per story (default: 2)

PROVIDER REPLACEMENT MODE (LLM-013):
    --provider <provider>   Primary provider for implementation (default: claude)
                           Options: claude, openai, gemini, deepseek
                           WARNING: Non-Claude providers have reduced capabilities
    --model <model>         Override model selection for provider
                           Examples: gpt-4o, gemini-2.0-flash, deepseek-chat

VALIDATION & TESTING:
    --validate-classifier   Run classification accuracy tests (requires >80% for autonomous mode)

DESCRIPTION:
    claude-loop runs Claude Code in repeated iterations to implement complete
    features based on a Product Requirements Document (PRD). Each iteration:

    1. Reads prd.json and progress.txt for context
    2. Picks the highest priority incomplete user story
    3. Auto-selects specialist agents based on story keywords
    4. Implements the story with agent expertise
    5. Runs quality checks (tests, typecheck, lint)
    6. Commits changes and updates state files
    7. Repeats until all stories pass or max iterations reached

AGENT INTEGRATION (Hybrid Approach):
    claude-loop comes with bundled core agents that work out of the box:
    - code-reviewer, test-runner, debugger, security-auditor, git-workflow

    For each story, claude-loop will:
    - Analyze keywords (test, security, python, etc.)
    - Load matching specialist agent prompts
    - Combine agent expertise with iteration instructions
    - Use up to --max-agents specialists per story

    Use --agents-dir to add external specialists on top of bundled agents.

    Agent Tiers:
      1 = Core (bundled: code-reviewer, test-runner, debugger, etc.)
      2 = Curated specialists (python-dev, typescript-specialist, etc.)
      3 = Domain-specific (physical AI, industry-specific)
      4 = Community (untrusted, disabled by default)

UNITY AUTOMATION MODE:
    The --unity flag enables Unity Editor automation for Quest 3 XR development.
    Supported commands:
      unity.setup_quest3   - Full Quest 3 SDK setup workflow
      unity.build          - Build APK for Android/Quest
      unity.deploy         - Deploy APK to connected Quest device
      unity.install_meta_sdk - Install Meta XR SDK from Asset Store
      unity.configure_xr   - Configure XR settings for a platform

    Workflow files (YAML) can define multi-step Unity automation sequences.

SELF-IMPROVEMENT WORKFLOW:
    claude-loop includes a self-improvement pipeline that:
    1. Logs execution data and classifies failures
    2. Clusters similar failures into patterns
    3. Analyzes root causes with 5-Whys decomposition
    4. Generalizes to capability gaps
    5. Generates improvement PRDs automatically

    Use --list-improvements to see generated PRDs pending review.
    Use --approve-improvement to approve and --execute-improvement to run.
    Use --rollback-improvement to revert changes if an improvement causes issues.

    PRD Status Lifecycle:
      pending_review -> approved -> in_progress -> complete -> rolled_back
                    \-> rejected

EXAMPLES:
    # Works out of the box with bundled agents
    ./claude-loop.sh

    # Add external specialists for more expertise
    ./claude-loop.sh --agents-dir ~/claude-agents

    # Unity automation mode for Quest 3 development
    ./claude-loop.sh --unity

    # Full options
    ./claude-loop.sh -a ~/claude-agents -m 20 --max-agents 3 -v

    # Improvement management
    ./claude-loop.sh --list-improvements
    ./claude-loop.sh --review-improvement improve-file-handling-abc123
    ./claude-loop.sh --approve-improvement improve-file-handling-abc123 --notes "Looks good"
    ./claude-loop.sh --reject-improvement improve-ui-abc789 --reason "Too risky"
    ./claude-loop.sh --execute-improvement improve-file-handling-abc123
    ./claude-loop.sh --rollback-improvement improve-file-handling-abc123 --reason "Caused test failures"

FILES (legacy mode - ./prd.json):
    prd.json      - Task state machine with user stories
    progress.txt  - Append-only log of learnings
    AGENTS.md     - Pattern documentation for future iterations
    prompt.md     - Instructions for each Claude iteration

FILES (new PRD structure - prds/active/*):
    prds/
    ├── active/         - PRDs currently in progress
    │   └── my-feature/
    │       ├── prd.json        - User stories
    │       ├── MANIFEST.yaml   - PRD metadata and status
    │       └── progress.txt    - Iteration learnings
    ├── completed/      - Successfully completed PRDs (auto-moved)
    ├── abandoned/      - Abandoned PRDs
    └── drafts/         - Draft PRDs (not yet approved)

    When all stories pass:
    1. MANIFEST.yaml status is updated to 'completed'
    2. PRD directory is moved from prds/active/ to prds/completed/

    Use lib/prd-manager.py for PRD lifecycle management:
    - prd-manager.py create DOC-001 "My Feature"
    - prd-manager.py approve DOC-001
    - prd-manager.py list --status active

EOF
}

check_dependencies() {
    local missing=()

    if ! command -v claude &> /dev/null; then
        missing+=("claude")
    fi

    if ! command -v jq &> /dev/null; then
        missing+=("jq")
    fi

    if ! command -v git &> /dev/null; then
        missing+=("git")
    fi

    if [ ${#missing[@]} -ne 0 ]; then
        log_error "Missing required dependencies: ${missing[*]}"
        log_info "Please install them and try again."
        exit 1
    fi
}

check_git_repo() {
    if ! git rev-parse --is-inside-work-tree &> /dev/null; then
        log_error "Not inside a git repository."
        log_info "Please initialize a git repository first: git init"
        exit 1
    fi
}

check_prd_exists() {
    if [ ! -f "$PRD_FILE" ]; then
        log_error "PRD file not found: $PRD_FILE"
        log_info "Create a prd.json file first. You can use:"
        log_info "  1. claude \"/prd <feature description>\" to generate a PRD"
        log_info "  2. claude \"/claude-loop <PRD.md>\" to convert to prd.json"
        log_info "  3. Copy and customize prd.json.example"
        log_info "  4. Create a PRD with: python3 lib/prd-manager.py create <PRD-ID> \"Title\""
        exit 1
    fi
}

# Auto-detect active PRD if only one exists in prds/active/
auto_detect_active_prd() {
    local prds_active_dir="${SCRIPT_DIR}/prds/active"

    # Check if prds/active/ exists
    if [ ! -d "$prds_active_dir" ]; then
        return 1
    fi

    # Find all prd.json files in prds/active/*/
    local prd_files=()
    for dir in "$prds_active_dir"/*/; do
        if [ -d "$dir" ] && [ -f "$dir/prd.json" ]; then
            prd_files+=("$dir/prd.json")
        fi
    done

    local count=${#prd_files[@]}

    if [ "$count" -eq 0 ]; then
        log_debug "No active PRDs found in prds/active/"
        return 1
    elif [ "$count" -eq 1 ]; then
        PRD_FILE="${prd_files[0]}"
        PRD_DIR="$(dirname "$PRD_FILE")"
        log_info "Auto-detected active PRD: $PRD_FILE"
        return 0
    else
        log_warn "Multiple active PRDs found in prds/active/:"
        for prd in "${prd_files[@]}"; do
            log_warn "  - $prd"
        done
        log_info "Please specify which PRD to use with --prd <path>"
        return 1
    fi
}

# Resolve PRD path - supports new prds/active/* structure
resolve_prd_path() {
    local prd_path="$1"

    # If path is relative to prds/active/, expand it
    if [[ "$prd_path" == prds/active/* ]] || [[ "$prd_path" == ./prds/active/* ]]; then
        # Convert to absolute path
        local full_path="${SCRIPT_DIR}/${prd_path#./}"
        if [ -f "$full_path" ]; then
            PRD_FILE="$full_path"
            PRD_DIR="$(dirname "$full_path")"
            return 0
        fi
    fi

    # Check if it's a directory containing prd.json
    if [ -d "$prd_path" ] && [ -f "$prd_path/prd.json" ]; then
        PRD_FILE="$prd_path/prd.json"
        PRD_DIR="$prd_path"
        return 0
    fi

    # Check if it's a direct path to prd.json
    if [ -f "$prd_path" ]; then
        PRD_FILE="$prd_path"
        PRD_DIR="$(dirname "$prd_path")"
        return 0
    fi

    # Check if it's a PRD ID and search in prds/active/
    local prds_active_dir="${SCRIPT_DIR}/prds/active"
    if [ -d "$prds_active_dir" ]; then
        for dir in "$prds_active_dir"/*/; do
            if [ -d "$dir" ] && [ -f "$dir/prd.json" ]; then
                # Check manifest for matching ID
                local manifest_file="$dir/MANIFEST.yaml"
                if [ -f "$manifest_file" ]; then
                    local prd_id
                    prd_id=$(grep -E '^id:' "$manifest_file" | head -1 | cut -d':' -f2 | tr -d ' ')
                    if [ "$prd_id" = "$prd_path" ]; then
                        PRD_FILE="$dir/prd.json"
                        PRD_DIR="$dir"
                        log_info "Resolved PRD ID '$prd_path' to: $PRD_FILE"
                        return 0
                    fi
                fi
            fi
        done
    fi

    # Fallback to treating it as a file path
    PRD_FILE="$prd_path"
    PRD_DIR=""
    return 0
}

check_prompt_exists() {
    if [ ! -f "$PROMPT_FILE" ]; then
        log_error "Prompt file not found: $PROMPT_FILE"
        log_info "Please ensure prompt.md exists in the script directory."
        exit 1
    fi
}

check_execution_logger() {
    if [ ! -f "$EXECUTION_LOGGER" ]; then
        log_warn "Execution logger not found: $EXECUTION_LOGGER"
        EXECUTION_LOGGING_ENABLED=false
        return
    fi

    # Source the execution logger
    source "$EXECUTION_LOGGER"
    log_info "Execution logging: Enabled"
}

check_prompt_augmenter() {
    if ! $EXPERIENCE_AUGMENTATION_ENABLED; then
        log_info "Experience augmentation: Disabled (--no-experience)"
        return
    fi

    if [ ! -f "$PROMPT_AUGMENTER" ]; then
        log_warn "Prompt augmenter not found: $PROMPT_AUGMENTER"
        EXPERIENCE_AUGMENTATION_ENABLED=false
        return
    fi

    # Check if Python 3 is available
    if ! command -v python3 &> /dev/null; then
        log_warn "Python3 not found, disabling experience augmentation"
        EXPERIENCE_AUGMENTATION_ENABLED=false
        return
    fi

    log_info "Experience augmentation: Enabled"
}

# ============================================================================
# Session State Integration (INV-007)
# ============================================================================

check_session_state() {
    if ! $SESSION_STATE_ENABLED; then
        log_debug "Session state: Disabled"
        return 1
    fi

    if [ ! -f "$SESSION_STATE_SCRIPT" ]; then
        log_warn "Session state script not found: $SESSION_STATE_SCRIPT"
        SESSION_STATE_ENABLED=false
        return 1
    fi

    # Source the session state script
    source "$SESSION_STATE_SCRIPT"
    log_info "Session state: Enabled (progress auto-saves)"
    return 0
}

# Initialize or resume session
# Returns: 0 if new session, iteration number if resuming
init_or_resume_session() {
    if ! $SESSION_STATE_ENABLED; then
        return 0
    fi

    # Check for specific session ID to resume
    if [ -n "$RESUME_FROM_SESSION" ]; then
        log_info "Attempting to resume session: $RESUME_FROM_SESSION"
        if resume_session_by_id "$RESUME_FROM_SESSION" > /dev/null 2>&1; then
            local resume_info
            resume_info=$(resume_session "true")
            local resume_iter
            resume_iter=$(echo "$resume_info" | jq -r '.iteration // 0')
            echo "$resume_iter"
            return 0
        else
            log_error "Session not found: $RESUME_FROM_SESSION"
            exit 1
        fi
    fi

    # Check for resumable session
    if $RESUME_MODE && has_resumable_session "$PRD_FILE"; then
        echo ""
        log_info "Found previous session to resume"
        local resume_info
        resume_info=$(resume_session "true")
        local resume_iter
        resume_iter=$(echo "$resume_info" | jq -r '.iteration // 0')
        local resume_completed
        resume_completed=$(echo "$resume_info" | jq -r '.stories_completed // 0')
        local resume_total
        resume_total=$(echo "$resume_info" | jq -r '.stories_total // 0')

        log_success "Resuming: $resume_completed/$resume_total stories complete, iteration $resume_iter"
        echo ""

        # Return the iteration to start from
        echo "$resume_iter"
        return 0
    fi

    # Initialize new session
    init_session "$PRD_FILE" > /dev/null 2>&1 || true
    echo "0"
}

# Save session state after story progress
# Usage: save_story_progress <story_id> <iteration> [phase]
save_story_progress() {
    if ! $SESSION_STATE_ENABLED; then
        return 0
    fi

    local story_id="$1"
    local iteration="$2"
    local phase="${3:-$CURRENT_PHASE}"

    save_session_state "$story_id" "$iteration" "$phase" 2>/dev/null || true
}

# Mark session as complete
finish_session() {
    if ! $SESSION_STATE_ENABLED; then
        return 0
    fi

    complete_session 2>/dev/null || true
}

# List available sessions
show_sessions() {
    if ! $SESSION_STATE_ENABLED; then
        log_warn "Session state not enabled"
        return 1
    fi

    check_session_state || return 1
    list_sessions "text"
}

get_experience_augmentation() {
    local problem_text="$1"
    local story_id="$2"

    if ! $EXPERIENCE_AUGMENTATION_ENABLED; then
        return
    fi

    # Run the prompt augmenter to get relevant experiences
    local augmentation
    augmentation=$(python3 "$PROMPT_AUGMENTER" augment "$problem_text" \
        --project-path "." \
        --min-helpful-rate "$MIN_HELPFUL_RATE" \
        --max-experiences "$MAX_EXPERIENCES" \
        2>/dev/null) || true

    # Return the augmentation if not empty
    if [ -n "$augmentation" ] && [ "$augmentation" != "" ]; then
        # Log the augmentation for tracking
        if $EXECUTION_LOGGING_ENABLED; then
            # Get augmentation metadata in JSON
            local aug_meta
            aug_meta=$(python3 "$PROMPT_AUGMENTER" check "$problem_text" \
                --project-path "." \
                --min-helpful-rate "$MIN_HELPFUL_RATE" \
                --max-experiences "$MAX_EXPERIENCES" \
                --json 2>/dev/null) || aug_meta="{}"

            # Extract counts for logging
            local exp_count
            exp_count=$(echo "$aug_meta" | jq -r '.experience_count // 0' 2>/dev/null) || exp_count=0

            log_debug "Experience augmentation: $exp_count experience(s) included"
        fi

        echo "$augmentation"
    fi
}

check_agents_dir() {
    # Check if agent registry exists
    if [ ! -f "$AGENT_REGISTRY" ]; then
        log_warn "Agent registry not found: $AGENT_REGISTRY"
        log_info "Agent integration disabled."
        AGENTS_ENABLED=false
        return
    fi

    # Check bundled agents (always available)
    if [ -d "$BUNDLED_AGENTS_DIR" ]; then
        local bundled_count
        bundled_count=$(ls -1 "$BUNDLED_AGENTS_DIR"/*.md 2>/dev/null | wc -l | tr -d ' ')
        if [ "$bundled_count" -gt 0 ]; then
            log_info "Bundled agents: $bundled_count core agents available"
        fi
    else
        log_warn "Bundled agents directory not found: $BUNDLED_AGENTS_DIR"
    fi

    # Check external agents directory (optional, for additional specialists)
    if [ -n "$AGENTS_DIR" ]; then
        # Expand tilde
        AGENTS_DIR="${AGENTS_DIR/#\~/$HOME}"

        if [ -d "$AGENTS_DIR" ]; then
            log_info "External agents: $AGENTS_DIR"
        else
            log_warn "External agents directory not found: $AGENTS_DIR"
            log_info "Using bundled agents only."
            AGENTS_DIR=""
        fi
    fi

    # Agents enabled if we have bundled or external agents
    if [ -d "$BUNDLED_AGENTS_DIR" ] || [ -n "$AGENTS_DIR" ]; then
        AGENTS_ENABLED=true
    else
        log_warn "No agents available. Agent integration disabled."
        AGENTS_ENABLED=false
    fi
}

get_branch_from_prd() {
    jq -r '.branchName // "feature/claude-loop"' "$PRD_FILE"
}

get_project_name() {
    jq -r '.project // "unnamed-project"' "$PRD_FILE"
}

get_incomplete_stories_count() {
    jq '[.userStories[] | select(.passes == false)] | length' "$PRD_FILE"
}

get_total_stories_count() {
    jq '.userStories | length' "$PRD_FILE"
}

get_next_story() {
    # Get the highest priority (lowest number) story with passes=false
    jq -r '[.userStories[] | select(.passes == false)] | sort_by(.priority) | .[0] | "\(.id)|\(.title)|\(.description)"' "$PRD_FILE"
}

get_story_text() {
    # Get full story details for agent selection
    local story_id="$1"
    jq -r --arg id "$story_id" '.userStories[] | select(.id == $id) | "\(.title) \(.description) \(.acceptanceCriteria | join(" "))"' "$PRD_FILE"
}

archive_previous_run() {
    local current_branch="$1"

    if [ -f "$LAST_BRANCH_FILE" ]; then
        local last_branch
        last_branch=$(cat "$LAST_BRANCH_FILE")

        if [ "$last_branch" != "$current_branch" ]; then
            log_info "Branch changed from '$last_branch' to '$current_branch'"
            log_info "Archiving previous run..."

            local timestamp
            timestamp=$(date +%Y%m%d_%H%M%S)
            local archive_path="${ARCHIVE_DIR}/${last_branch//\//_}_${timestamp}"

            mkdir -p "$archive_path"

            # Archive state files if they exist
            [ -f "progress.txt" ] && cp "progress.txt" "$archive_path/"
            [ -f "$PRD_FILE" ] && cp "$PRD_FILE" "$archive_path/"

            log_success "Archived to: $archive_path"

            # Reset progress for new branch
            rm -f "progress.txt"
        fi
    fi

    # Update last branch tracker
    echo "$current_branch" > "$LAST_BRANCH_FILE"
}

ensure_correct_branch() {
    local target_branch="$1"
    local current_branch
    current_branch=$(git branch --show-current)

    if [ "$current_branch" != "$target_branch" ]; then
        log_info "Switching to branch: $target_branch"

        # Check if branch exists
        if git show-ref --verify --quiet "refs/heads/$target_branch"; then
            git checkout "$target_branch"
        else
            log_info "Creating new branch: $target_branch"
            git checkout -b "$target_branch"
        fi
    fi
}

initialize_progress_file() {
    # Determine progress file location
    # If PRD_DIR is set (new structure), create progress.txt inside PRD directory
    # Otherwise, use PROGRESS_FILE or default to ./progress.txt
    local progress_path
    if [ -n "$PROGRESS_FILE" ]; then
        progress_path="$PROGRESS_FILE"
    elif [ -n "$PRD_DIR" ]; then
        progress_path="$PRD_DIR/progress.txt"
    else
        progress_path="./progress.txt"
    fi

    # Export for use by other functions
    PROGRESS_FILE="$progress_path"

    if [ ! -f "$progress_path" ]; then
        local project_name
        project_name=$(get_project_name)

        # Ensure parent directory exists
        mkdir -p "$(dirname "$progress_path")"

        cat > "$progress_path" << EOF
# Progress Log: ${project_name}
# Created: $(date '+%Y-%m-%d %H:%M:%S')
#
# This file tracks learnings and progress across claude-loop iterations.
# Each iteration appends its findings here for future iterations to learn from.

## Codebase Patterns
<!-- Critical patterns discovered - updated by each iteration -->

---

## Iteration History

EOF
        log_info "Initialized progress.txt at: $progress_path"
    else
        log_debug "Progress file exists: $progress_path"
    fi
}

initialize_agents_file() {
    if [ ! -f "AGENTS.md" ]; then
        cat > "AGENTS.md" << EOF
# AGENTS.md - Pattern Documentation

This file documents patterns discovered during development for AI agents
and future developers. Updated automatically by claude-loop iterations.

## Project Structure

<!-- Document key directories and their purposes -->

## Common Commands

\`\`\`bash
# Add project-specific commands here
\`\`\`

## Discovered Patterns

<!-- Patterns learned during implementation -->

## Gotchas & Warnings

<!-- Common pitfalls to avoid -->

EOF
        log_info "Initialized AGENTS.md"
    fi
}

# ============================================================================
# Checkpoint Functions
# ============================================================================

get_workflow_id() {
    # Generate a workflow ID based on branch name and project
    local project_name
    project_name=$(get_project_name)
    local branch_name
    branch_name=$(get_branch_from_prd)
    echo "${project_name}_${branch_name}" | tr '/' '_' | tr -cd '[:alnum:]_-'
}

get_checkpoint_file() {
    local workflow_id="$1"
    local step_index="$2"
    local step_id="$3"
    local timestamp
    timestamp=$(date +%Y%m%d_%H%M%S)
    local safe_step_id
    safe_step_id=$(echo "$step_id" | tr -cd '[:alnum:]_-')
    echo "${CHECKPOINT_DIR}/${workflow_id}/$(printf '%04d' "$step_index")_${safe_step_id}_${timestamp}.json"
}

list_checkpoints() {
    local workflow_id="$1"
    local checkpoint_path="${CHECKPOINT_DIR}/${workflow_id}"

    if [ -d "$checkpoint_path" ]; then
        find "$checkpoint_path" -name "*.json" -type f 2>/dev/null | sort
    fi
}

get_latest_checkpoint() {
    local workflow_id="$1"
    list_checkpoints "$workflow_id" | tail -1
}

load_checkpoint() {
    local checkpoint_file="$1"

    if [ -f "$checkpoint_file" ]; then
        cat "$checkpoint_file"
    fi
}

save_checkpoint() {
    local workflow_id="$1"
    local step_id="$2"
    local step_index="$3"
    local context="$4"

    # Ensure checkpoint directory exists
    local checkpoint_path="${CHECKPOINT_DIR}/${workflow_id}"
    mkdir -p "$checkpoint_path"

    # Generate checkpoint file path
    local checkpoint_file
    checkpoint_file=$(get_checkpoint_file "$workflow_id" "$step_index" "$step_id")

    # Create checkpoint JSON
    local timestamp
    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)

    cat > "$checkpoint_file" << EOF
{
  "workflow_id": "${workflow_id}",
  "step_id": "${step_id}",
  "step_index": ${step_index},
  "timestamp": "${timestamp}",
  "context": ${context:-"{}"}
}
EOF

    log_debug "Checkpoint saved: $checkpoint_file"
    echo "$checkpoint_file"
}

cleanup_checkpoints() {
    local workflow_id="$1"
    local keep_latest="${2:-false}"
    local checkpoint_path="${CHECKPOINT_DIR}/${workflow_id}"

    if [ ! -d "$checkpoint_path" ]; then
        return
    fi

    if $keep_latest; then
        # Keep only the latest checkpoint
        local checkpoints
        checkpoints=$(list_checkpoints "$workflow_id")
        local count
        count=$(echo "$checkpoints" | wc -l | tr -d ' ')

        if [ "$count" -gt 1 ]; then
            echo "$checkpoints" | head -n $((count - 1)) | while read -r cp; do
                rm -f "$cp"
            done
        fi
    else
        # Remove all checkpoints
        rm -rf "$checkpoint_path"
    fi

    # Remove checkpoint directory if empty
    if [ -d "$checkpoint_path" ] && [ -z "$(ls -A "$checkpoint_path" 2>/dev/null)" ]; then
        rmdir "$checkpoint_path" 2>/dev/null || true
    fi

    log_info "Checkpoints cleaned up for workflow: $workflow_id"
}

check_resume_from_checkpoint() {
    if ! $RESUME_MODE; then
        return 1
    fi

    local workflow_id
    workflow_id=$(get_workflow_id)
    local latest_checkpoint
    latest_checkpoint=$(get_latest_checkpoint "$workflow_id")

    if [ -z "$latest_checkpoint" ] || [ ! -f "$latest_checkpoint" ]; then
        log_info "No checkpoint found to resume from"
        return 1
    fi

    log_info "Found checkpoint: $latest_checkpoint"

    # Parse checkpoint to get step info
    local step_id
    step_id=$(jq -r '.step_id // ""' "$latest_checkpoint" 2>/dev/null)
    local step_index
    step_index=$(jq -r '.step_index // 0' "$latest_checkpoint" 2>/dev/null)

    if [ -n "$step_id" ]; then
        log_success "Resuming from step: $step_id (index: $step_index)"
        echo "$step_index"
        return 0
    fi

    return 1
}

# ============================================================================
# Improvement Management Functions
# ============================================================================

check_improvement_manager() {
    if [ ! -f "$IMPROVEMENT_MANAGER" ]; then
        log_error "Improvement manager not found: $IMPROVEMENT_MANAGER"
        return 1
    fi

    # Source the improvement manager for function access
    source "$IMPROVEMENT_MANAGER"
    return 0
}

# ============================================================================
# Gap Analysis Daemon Functions
# ============================================================================

check_gap_analysis_daemon() {
    if [ ! -f "$GAP_ANALYSIS_DAEMON" ]; then
        log_error "Gap analysis daemon not found: $GAP_ANALYSIS_DAEMON"
        return 1
    fi

    if [ ! -x "$GAP_ANALYSIS_DAEMON" ]; then
        log_warn "Making gap analysis daemon executable..."
        chmod +x "$GAP_ANALYSIS_DAEMON"
    fi

    return 0
}

run_daemon_mode() {
    # Check if we're in daemon mode
    if [ -z "$DAEMON_MODE" ]; then
        return 1  # Not in daemon mode, continue normal execution
    fi

    # Ensure daemon script is available
    if ! check_gap_analysis_daemon; then
        exit 1
    fi

    case "$DAEMON_MODE" in
        start)
            log_info "Starting gap analysis daemon..."
            "$GAP_ANALYSIS_DAEMON" start
            exit $?
            ;;
        stop)
            log_info "Stopping gap analysis daemon..."
            "$GAP_ANALYSIS_DAEMON" stop
            exit $?
            ;;
        status)
            "$GAP_ANALYSIS_DAEMON" status
            exit 0
            ;;
        *)
            log_error "Unknown daemon mode: $DAEMON_MODE"
            exit 1
            ;;
    esac
}

run_improvement_mode() {
    # Check if we're in improvement mode
    if [ -z "$IMPROVEMENT_MODE" ]; then
        return 1  # Not in improvement mode, continue normal execution
    fi

    # Ensure improvement manager is available
    if ! check_improvement_manager; then
        exit 1
    fi

    case "$IMPROVEMENT_MODE" in
        list)
            log_info "Listing improvement PRDs..."
            list_improvements "all" "text"
            exit 0
            ;;
        review)
            if [ -z "$IMPROVEMENT_TARGET" ]; then
                log_error "PRD name is required for --review-improvement"
                exit 1
            fi
            log_info "Reviewing improvement PRD: $IMPROVEMENT_TARGET"
            review_improvement "$IMPROVEMENT_TARGET" "text"
            exit 0
            ;;
        approve)
            if [ -z "$IMPROVEMENT_TARGET" ]; then
                log_error "PRD name is required for --approve-improvement"
                exit 1
            fi
            log_info "Approving improvement PRD: $IMPROVEMENT_TARGET"
            approve_improvement "$IMPROVEMENT_TARGET" "$IMPROVEMENT_NOTES"
            exit 0
            ;;
        reject)
            if [ -z "$IMPROVEMENT_TARGET" ]; then
                log_error "PRD name is required for --reject-improvement"
                exit 1
            fi
            if [ -z "$IMPROVEMENT_REASON" ]; then
                log_error "Rejection reason is required (use --reason \"...\")"
                exit 1
            fi
            log_info "Rejecting improvement PRD: $IMPROVEMENT_TARGET"
            reject_improvement "$IMPROVEMENT_TARGET" "$IMPROVEMENT_REASON"
            exit 0
            ;;
        validate)
            if [ -z "$IMPROVEMENT_TARGET" ]; then
                log_error "PRD name is required for --validate-improvement"
                exit 1
            fi
            log_info "Validating improvement PRD: $IMPROVEMENT_TARGET"
            local force_flag=""
            if $IMPROVEMENT_FORCE; then
                force_flag="true"
            fi
            validate_improvement "$IMPROVEMENT_TARGET" "$force_flag"
            exit $?
            ;;
        execute)
            if [ -z "$IMPROVEMENT_TARGET" ]; then
                log_error "PRD name is required for --execute-improvement"
                exit 1
            fi
            log_info "Executing improvement PRD: $IMPROVEMENT_TARGET"
            local validate_flag="false"
            local force_flag="false"
            if $IMPROVEMENT_VALIDATE; then
                validate_flag="true"
            fi
            if $IMPROVEMENT_FORCE; then
                force_flag="true"
            fi
            execute_improvement "$IMPROVEMENT_TARGET" "$validate_flag" "$force_flag"
            exit $?
            ;;
        history)
            log_info "Showing improvement history..."
            show_history 20 "text"
            exit 0
            ;;
        rollback)
            if [ -z "$IMPROVEMENT_TARGET" ]; then
                log_error "PRD name is required for --rollback-improvement"
                exit 1
            fi
            log_warn "Rolling back improvement PRD: $IMPROVEMENT_TARGET"
            rollback_improvement "$IMPROVEMENT_TARGET" "$IMPROVEMENT_REASON" "$IMPROVEMENT_DRY_RUN"
            exit $?
            ;;
        *)
            log_error "Unknown improvement mode: $IMPROVEMENT_MODE"
            exit 1
            ;;
    esac
}

# ============================================================================
# Single-Command Entry Point (INV-008)
# ============================================================================

# Generate PRD from feature description
# Usage: generate_prd_from_description "feature description"
# Sets PRD_FILE to the generated file path
generate_prd_from_description() {
    local description="$1"

    if [ ! -f "$PRD_GENERATOR" ]; then
        log_error "PRD generator not found: $PRD_GENERATOR"
        log_info "Please ensure lib/prd-from-description.py exists."
        exit 1
    fi

    if ! command -v python3 &> /dev/null; then
        log_error "Python3 is required for PRD generation."
        exit 1
    fi

    log_info "Generating PRD from description..."
    log_info "Description: $description"
    echo ""

    # Generate PRD to temporary location first to capture output
    local output_file="prd.json"

    # Run the generator and capture output
    if ! python3 "$PRD_GENERATOR" generate "$description" --output "$output_file" 2>&1; then
        log_error "Failed to generate PRD from description"
        exit 1
    fi

    # Update PRD_FILE to point to generated file
    PRD_FILE="$output_file"

    log_success "PRD generated: $PRD_FILE"
}

# Display auto-detection summary (INV-008)
# Shows complexity, track, phases before execution
display_auto_detection_summary() {
    if [ ! -f "$COMPLEXITY_DETECTOR" ]; then
        return
    fi

    if ! command -v python3 &> /dev/null; then
        return
    fi

    # Get detection results
    local detection_json
    detection_json=$(python3 "$COMPLEXITY_DETECTOR" detect --prd "$PRD_FILE" --show-track --show-phases --json 2>/dev/null) || return

    # Parse results
    local level
    level=$(echo "$detection_json" | jq -r '.level // 2')
    local level_name
    level_name=$(echo "$detection_json" | jq -r '.level_name // "medium"')
    local track
    track=$(echo "$detection_json" | jq -r '.track // "standard"')
    local phases
    phases=$(echo "$detection_json" | jq -r '.phases | join(" → ")' 2>/dev/null) || phases="implementation"
    local score
    score=$(echo "$detection_json" | jq -r '.score // 0')

    local story_count
    story_count=$(get_total_stories_count)

    # Get quality gates for this level (INV-009)
    local quality_gates=""
    if [ -f "$QUALITY_GATES_SCRIPT" ] && $QUALITY_GATES_ENABLED; then
        quality_gates=$(python3 "$QUALITY_GATES_SCRIPT" get "$level" --json 2>/dev/null | \
                       jq -r '.enabled_gates | join(", ")' 2>/dev/null) || quality_gates=""
    fi

    echo ""
    echo "═══════════════════════════════════════════════════════════════"
    echo "              AUTO-DETECTION RESULTS (INV-008/009)"
    echo "═══════════════════════════════════════════════════════════════"
    echo ""
    echo -e "  ${CYAN}Complexity:${NC}  Level $level ($level_name) - Score: $score"
    echo -e "  ${CYAN}Track:${NC}       $track"
    echo -e "  ${CYAN}Phases:${NC}      $phases"
    echo -e "  ${CYAN}Stories:${NC}     $story_count user stories"
    if [ -n "$quality_gates" ]; then
        echo -e "  ${CYAN}Gates:${NC}       $quality_gates"
    fi
    echo ""
    echo "═══════════════════════════════════════════════════════════════"
    echo ""
}

# ============================================================================
# Phase Detection (INV-005)
# ============================================================================

COMPLEXITY_DETECTOR="${SCRIPT_DIR}/lib/complexity-detector.py"
CURRENT_PHASE=""  # Tracks the current execution phase

# Get phases based on PRD complexity
# Usage: get_prd_phases
# Returns: space-separated list of phases (e.g., "planning solutioning implementation")
get_prd_phases() {
    if [ ! -f "$COMPLEXITY_DETECTOR" ]; then
        log_debug "Complexity detector not found, defaulting to implementation phase"
        echo "implementation"
        return
    fi

    if ! command -v python3 &> /dev/null; then
        log_debug "Python3 not found, defaulting to implementation phase"
        echo "implementation"
        return
    fi

    local phases
    phases=$(python3 "$COMPLEXITY_DETECTOR" detect --prd "$PRD_FILE" --show-phases --json 2>/dev/null | \
             jq -r '.phases | join(" ")' 2>/dev/null) || phases=""

    if [ -z "$phases" ]; then
        echo "implementation"
    else
        echo "$phases"
    fi
}

# Get current phase based on completed stories
# Usage: get_current_phase
# Returns: current phase name (analysis, planning, solutioning, or implementation)
get_current_phase() {
    local total_stories
    total_stories=$(get_total_stories_count)
    local incomplete_stories
    incomplete_stories=$(get_incomplete_stories_count)
    local completed=$((total_stories - incomplete_stories))
    local progress_ratio=0

    if [ "$total_stories" -gt 0 ]; then
        progress_ratio=$((completed * 100 / total_stories))
    fi

    # Get phases for this PRD
    local phases
    phases=$(get_prd_phases)

    # Convert to array
    local phase_array=($phases)
    local num_phases=${#phase_array[@]}

    if [ "$num_phases" -eq 0 ] || [ "$num_phases" -eq 1 ]; then
        echo "implementation"
        return
    fi

    # Determine current phase based on progress
    # Each phase gets an equal portion of the progress bar
    local phase_size=$((100 / num_phases))
    local phase_index=$((progress_ratio / phase_size))

    # Clamp to valid index
    if [ "$phase_index" -ge "$num_phases" ]; then
        phase_index=$((num_phases - 1))
    fi

    echo "${phase_array[$phase_index]}"
}

# Set the current phase (can be overridden via environment or flag)
set_current_phase() {
    local phase="${1:-}"

    if [ -n "$phase" ]; then
        CURRENT_PHASE="$phase"
    else
        CURRENT_PHASE=$(get_current_phase)
    fi

    log_debug "Current phase: $CURRENT_PHASE"
}

# ============================================================================
# Quality Gates (INV-009)
# ============================================================================

# Get complexity level from PRD
# Usage: get_complexity_level
# Returns: complexity level 0-4
get_complexity_level() {
    # Return cached value if available
    if [ -n "$CURRENT_COMPLEXITY_LEVEL" ]; then
        echo "$CURRENT_COMPLEXITY_LEVEL"
        return
    fi

    if [ ! -f "$COMPLEXITY_DETECTOR" ]; then
        log_debug "Complexity detector not found, defaulting to level 2"
        CURRENT_COMPLEXITY_LEVEL="2"
        echo "2"
        return
    fi

    if ! command -v python3 &> /dev/null; then
        log_debug "Python3 not found, defaulting to level 2"
        CURRENT_COMPLEXITY_LEVEL="2"
        echo "2"
        return
    fi

    local level
    level=$(python3 "$COMPLEXITY_DETECTOR" detect --prd "$PRD_FILE" --json 2>/dev/null | \
            jq -r '.level // 2' 2>/dev/null) || level="2"

    CURRENT_COMPLEXITY_LEVEL="$level"
    echo "$level"
}

# Get enabled quality gates for the current complexity level
# Usage: get_enabled_gates
# Returns: space-separated list of enabled gates
get_enabled_gates() {
    if [ ! -f "$QUALITY_GATES_SCRIPT" ]; then
        log_debug "Quality gates script not found"
        echo "tests"
        return
    fi

    local level
    level=$(get_complexity_level)

    local gates
    gates=$(python3 "$QUALITY_GATES_SCRIPT" get "$level" --json 2>/dev/null | \
            jq -r '.enabled_gates | join(" ")' 2>/dev/null) || gates="tests"

    echo "$gates"
}

# Display active quality gates (for verbose mode)
# Usage: display_quality_gates_summary
display_quality_gates_summary() {
    if ! $QUALITY_GATES_ENABLED; then
        return
    fi

    if [ ! -f "$QUALITY_GATES_SCRIPT" ]; then
        return
    fi

    local level
    level=$(get_complexity_level)

    if $VERBOSE; then
        log_info "Quality gates active for complexity level $level:"
        local gates
        gates=$(get_enabled_gates)
        log_debug "  Enabled: $gates"
    fi
}

# Run quality gates for the project
# Usage: run_quality_gates [--verbose]
# Returns: 0 if all blocking gates pass, 1 otherwise
run_quality_gates() {
    if ! $QUALITY_GATES_ENABLED; then
        log_debug "Quality gates disabled, skipping"
        return 0
    fi

    if [ ! -f "$QUALITY_GATES_SCRIPT" ]; then
        log_debug "Quality gates script not found, skipping"
        return 0
    fi

    local verbose_flag=""
    if $VERBOSE; then
        verbose_flag="--verbose"
    fi

    local level
    level=$(get_complexity_level)

    log_info "Running quality gates for complexity level $level..."

    # Run quality gates and capture result
    local result
    local exit_code=0
    result=$(python3 "$QUALITY_GATES_SCRIPT" run "$level" --json $verbose_flag 2>&1) || exit_code=$?

    # Parse result
    local all_passed
    all_passed=$(echo "$result" | jq -r '.all_passed // false' 2>/dev/null) || all_passed="false"

    local blocking_failures
    blocking_failures=$(echo "$result" | jq -r '.blocking_failures | length // 0' 2>/dev/null) || blocking_failures="0"

    local warnings
    warnings=$(echo "$result" | jq -r '.warnings | length // 0' 2>/dev/null) || warnings="0"

    # Report results
    if [ "$all_passed" = "true" ]; then
        log_success "All quality gates passed"
        return 0
    else
        if [ "$blocking_failures" != "0" ]; then
            log_error "Quality gates failed ($blocking_failures blocking failures)"
            # Show blocking failures
            echo "$result" | jq -r '.blocking_failures[]' 2>/dev/null | while read -r failure; do
                log_error "  ✗ $failure"
            done
            return 1
        fi

        if [ "$warnings" != "0" ]; then
            log_warn "Quality gates passed with $warnings warnings"
            # Show warnings
            echo "$result" | jq -r '.warnings[]' 2>/dev/null | while read -r warning; do
                log_warn "  ⚠ $warning"
            done
        fi

        return 0
    fi
}

# ============================================================================
# Completion Summary (INV-010)
# ============================================================================

# Display comprehensive completion summary at end of run
# Usage: display_completion_summary [--json] [--verbose]
display_completion_summary() {
    if ! $COMPLETION_SUMMARY_ENABLED; then
        return 0
    fi

    if [ ! -f "$COMPLETION_SUMMARY_SCRIPT" ]; then
        log_debug "Completion summary script not found: $COMPLETION_SUMMARY_SCRIPT"
        return 0
    fi

    if ! command -v python3 &> /dev/null; then
        log_debug "Python3 not found, skipping completion summary"
        return 0
    fi

    # Build command arguments
    local args="generate --prd $PRD_FILE"

    # Add session state if available
    if [ -f ".claude-loop/session-state.json" ]; then
        args="$args --session .claude-loop/session-state.json"
    fi

    # Find latest metrics file if available
    local latest_metrics=""
    if [ -d ".claude-loop/runs" ]; then
        latest_metrics=$(find .claude-loop/runs -name "metrics.json" -type f 2>/dev/null | sort -r | head -1)
        if [ -n "$latest_metrics" ]; then
            args="$args --metrics $latest_metrics"
        fi
    fi

    # Add verbose flag if enabled
    if $VERBOSE; then
        args="$args --verbose"
    fi

    # Run the completion summary script
    python3 "$COMPLETION_SUMMARY_SCRIPT" $args 2>/dev/null || {
        log_debug "Completion summary generation failed"
        return 0
    }
}

# ============================================================================
# Solutioning Generator (INV-011: Integration of INV-004)
# ============================================================================

# Check if solutioning should run based on complexity level
# Returns: 0 if solutioning should run, 1 otherwise
should_run_solutioning() {
    if ! $SOLUTIONING_ENABLED; then
        log_debug "Solutioning generation disabled"
        return 1
    fi

    if [ ! -f "$SOLUTIONING_GENERATOR" ]; then
        log_debug "Solutioning generator not found: $SOLUTIONING_GENERATOR"
        return 1
    fi

    if ! command -v python3 &> /dev/null; then
        log_debug "Python3 not found, skipping solutioning"
        return 1
    fi

    local level
    level=$(get_complexity_level)

    # Only run solutioning for Level >= 3
    if [ "$level" -ge 3 ]; then
        return 0
    else
        log_debug "Solutioning skipped: complexity level $level < 3"
        return 1
    fi
}

# Run solutioning generator to create architecture.md and ADRs
# Usage: run_solutioning_generator [--force]
# Returns: 0 on success, 1 on failure or skip
run_solutioning_generator() {
    local force_flag=""
    if [ "${1:-}" = "--force" ]; then
        force_flag="--force"
    fi

    if ! should_run_solutioning && [ -z "$force_flag" ]; then
        return 0  # Not needed, but not an error
    fi

    log_info "Running solutioning generator (Level >= 3 detected)..."

    # Determine output directory
    local output_dir="docs"
    if [ -n "$PRD_DIR" ]; then
        output_dir="$PRD_DIR/docs"
    fi

    # Build command arguments
    local args="generate --prd $PRD_FILE --output-dir $output_dir"
    if [ -n "$force_flag" ]; then
        args="$args --force"
    fi

    # Run the generator
    local result
    result=$(python3 "$SOLUTIONING_GENERATOR" $args 2>&1) || {
        log_warn "Solutioning generation encountered issues:"
        echo "$result" | head -5
        return 1
    }

    # Check what was generated
    local arch_file="$output_dir/architecture/architecture.md"
    local adrs_dir="$output_dir/adrs"

    if [ -f "$arch_file" ]; then
        log_success "Generated: $arch_file"
    fi

    if [ -d "$adrs_dir" ] && [ "$(ls -A "$adrs_dir" 2>/dev/null)" ]; then
        local adr_count
        adr_count=$(ls -1 "$adrs_dir"/*.md 2>/dev/null | wc -l | tr -d ' ')
        log_success "Generated: $adr_count ADR template(s) in $adrs_dir"
    fi

    return 0
}

# Display detected ADR topics without generating files
# Usage: display_detected_adrs
display_detected_adrs() {
    if [ ! -f "$SOLUTIONING_GENERATOR" ]; then
        return
    fi

    local level
    level=$(get_complexity_level)

    if [ "$level" -lt 3 ]; then
        return
    fi

    local detected
    detected=$(python3 "$SOLUTIONING_GENERATOR" detect-adrs --prd "$PRD_FILE" --json 2>/dev/null) || return

    local topics
    topics=$(echo "$detected" | jq -r '.detected_topics | keys | join(", ")' 2>/dev/null) || topics=""

    if [ -n "$topics" ] && [ "$topics" != "" ]; then
        log_info "ADR topics detected: $topics"
    fi
}

# ============================================================================
# Agent Integration Functions
# ============================================================================

select_agents_for_story() {
    local story_text="$1"
    local phase="${2:-$CURRENT_PHASE}"  # Use passed phase or current phase

    if ! $AGENTS_ENABLED; then
        return
    fi

    # Export environment for agent registry
    export MAX_AGENTS_PER_ITERATION
    export MAX_TOKENS_PER_AGENT
    export ENABLED_TIERS
    export LOCAL_AGENTS_DIR="$BUNDLED_AGENTS_DIR"

    # Call agent registry to select agents with phase awareness
    # Pass external AGENTS_DIR for additional specialists (empty string if not set)
    local selected_agents
    selected_agents=$("$AGENT_REGISTRY" select "$story_text" "$AGENTS_DIR" "$MAX_AGENTS_PER_ITERATION" "$phase" 2>/dev/null) || true

    # Log phase influence if verbose
    if $VERBOSE && [ -n "$phase" ] && [ "$phase" != "implementation" ]; then
        log_debug "Phase '$phase' influencing agent selection"
    fi

    echo "$selected_agents"
}

load_agent_prompts() {
    # Export bundled agents location for registry
    export LOCAL_AGENTS_DIR="$BUNDLED_AGENTS_DIR"

    local agents_list="$*"

    if [ -z "$agents_list" ]; then
        return
    fi

    echo ""
    echo "# Specialist Agent Expertise"
    echo ""
    echo "The following specialist knowledge is available for this story:"
    echo ""

    for agent in $agents_list; do
        if [ -n "$agent" ]; then
            log_agent "Loading: $agent"
            echo "---"
            echo "## $agent"
            echo ""
            # Pass external AGENTS_DIR for additional specialists
            "$AGENT_REGISTRY" load "$agent" "$AGENTS_DIR" 2>/dev/null || echo "# Agent $agent not found"
            echo ""
        fi
    done
}

build_iteration_prompt() {
    local story_id="$1"
    local story_text="$2"

    # Start with base prompt
    local full_prompt
    full_prompt=$(cat "$PROMPT_FILE")

    # Add experience augmentation if enabled
    if $EXPERIENCE_AUGMENTATION_ENABLED; then
        local experience_section
        experience_section=$(get_experience_augmentation "$story_text" "$story_id")

        if [ -n "$experience_section" ]; then
            # Prepend experience section to iteration prompt
            full_prompt="${experience_section}
${full_prompt}"
        fi
    fi

    # Add agent expertise if enabled
    if $AGENTS_ENABLED; then
        local selected_agents
        selected_agents=$(select_agents_for_story "$story_text")

        if [ -n "$selected_agents" ]; then
            local agent_count
            agent_count=$(echo "$selected_agents" | wc -l | tr -d ' ')
            log_agent "Selected $agent_count agent(s) for story $story_id"

            # Load agent prompts
            local agent_prompts
            agent_prompts=$(load_agent_prompts $selected_agents)

            # Prepend agent expertise to iteration prompt
            full_prompt="${agent_prompts}

---

${full_prompt}"
        else
            log_debug "No agents matched for this story"
        fi
    fi

    echo "$full_prompt"
}

# ============================================================================
# Review Panel Functions (LLM-007)
# ============================================================================

# Run multi-LLM review on completed story
run_review_panel() {
    local story_id=$1
    local story_title=$2

    if ! $REVIEW_ENABLED; then
        return 0  # Review not enabled, skip
    fi

    if [ ! -f "$REVIEW_PANEL_SCRIPT" ]; then
        log_warn "Review panel script not found: $REVIEW_PANEL_SCRIPT"
        return 0
    fi

    log_info "Running multi-LLM review panel for $story_id..."

    # Get the git diff for the completed story
    local diff_output
    diff_output=$(git diff HEAD~1 HEAD 2>/dev/null || echo "")

    if [ -z "$diff_output" ]; then
        log_warn "No changes detected for review, skipping"
        return 0
    fi

    # Get story context from prd.json
    local story_context
    story_context=$(jq -r ".userStories[] | select(.id == \"$story_id\") | {id, title, description, acceptanceCriteria}" "$PRD_FILE" 2>/dev/null || echo "{}")

    # Save diff to temp file
    local diff_file
    diff_file=$(mktemp)
    echo "$diff_output" > "$diff_file"

    # Save context to temp file
    local context_file
    context_file=$(mktemp)
    echo "$story_context" > "$context_file"

    # Build review command
    local review_cmd="python3 \"$REVIEW_PANEL_SCRIPT\" review --diff \"$diff_file\" --context \"$context_file\""

    # Add reviewers if specified
    if [ -n "$REVIEW_PROVIDERS" ]; then
        review_cmd="$review_cmd --reviewers $REVIEW_PROVIDERS"
    fi

    # Run review and capture output
    local review_output
    local review_exit_code=0
    review_output=$(eval "$review_cmd" 2>&1) || review_exit_code=$?

    # Clean up temp files
    rm -f "$diff_file" "$context_file"

    if [ $review_exit_code -ne 0 ]; then
        log_warn "Review panel failed: $review_output"
        return 1
    fi

    # Parse review results (expecting JSON)
    local consensus_score
    consensus_score=$(echo "$review_output" | jq -r '.consensus_score // 0' 2>/dev/null || echo "0")

    local total_issues
    total_issues=$(echo "$review_output" | jq -r '.total_issues // 0' 2>/dev/null || echo "0")

    local critical_issues
    critical_issues=$(echo "$review_output" | jq -r '.critical_issues // 0' 2>/dev/null || echo "0")

    log_info "Review Results: Score=$consensus_score/10, Issues=$total_issues (Critical=$critical_issues)"

    # Check if score meets threshold
    if [ "$consensus_score" -lt "$REVIEW_THRESHOLD" ]; then
        log_warn "Review score ($consensus_score) below threshold ($REVIEW_THRESHOLD)"

        # Return review results for potential fix cycle
        echo "$review_output"
        return 2  # Special exit code: needs fixes
    else
        log_success "Review passed! Score: $consensus_score/10"

        # Log review results
        echo "$review_output"
        return 0
    fi
}

# ============================================================================
# Iteration Functions
# ============================================================================

# Run iteration with non-Claude provider using agent-runtime
run_iteration_with_agent_runtime() {
    local iteration=$1
    local story_id=$2
    local story_title=$3
    local task_description=$4

    log_iteration "$iteration" "Working on: $story_id - $story_title (Provider: $PRIMARY_PROVIDER)"

    # Build task from story context
    local story_details
    story_details=$(jq -r --arg id "$story_id" '.userStories[] | select(.id == $id)' "$PRD_FILE")

    local acceptance_criteria
    acceptance_criteria=$(echo "$story_details" | jq -r '.acceptanceCriteria | join("\n- ")' 2>/dev/null || echo "")

    local task_prompt="
# Story: $story_id - $story_title

## Description
$task_description

## Acceptance Criteria
- $acceptance_criteria

## Instructions
Implement this story by:
1. Reading relevant files to understand the codebase
2. Making necessary code changes
3. Running tests to verify functionality
4. Committing changes with appropriate message

Use the available tools (read_file, write_file, run_bash, git_command) to complete this task.
Update the prd.json file to mark this story as complete (set passes: true).
"

    # Build agent-runtime command
    local runtime_cmd="python3 \"$AGENT_RUNTIME\" run --provider $PRIMARY_PROVIDER --task \"$task_prompt\""

    # Add model override if specified
    if [ -n "$PROVIDER_MODELS" ]; then
        runtime_cmd="$runtime_cmd --model $PROVIDER_MODELS"
    fi

    # Add JSON output for parsing
    runtime_cmd="$runtime_cmd --json"

    log_debug "Running agent-runtime with provider: $PRIMARY_PROVIDER"

    # Execute agent-runtime
    local output
    local exit_code=0
    output=$(eval "$runtime_cmd" 2>&1) || exit_code=$?

    # Parse JSON output
    local success
    success=$(echo "$output" | jq -r '.success // false' 2>/dev/null || echo "false")

    local error_msg
    error_msg=$(echo "$output" | jq -r '.error // ""' 2>/dev/null || echo "")

    if [ "$success" = "true" ]; then
        log_success "Story $story_id completed with $PRIMARY_PROVIDER"

        # Verify story was marked complete in prd.json
        local story_passes
        story_passes=$(jq -r ".userStories[] | select(.id == \"$story_id\") | .passes" "$PRD_FILE" 2>/dev/null || echo "false")

        if [ "$story_passes" = "true" ]; then
            return 0
        else
            log_warn "Story completed but not marked as passes=true in prd.json"
            return 1
        fi
    else
        log_error "Story $story_id failed: $error_msg"
        return 1
    fi
}

run_iteration() {
    local iteration=$1
    local output
    local exit_code=0

    # Update current phase based on progress
    set_current_phase

    # Get the next story to work on
    local story_info
    story_info=$(get_next_story)
    local story_id
    story_id=$(echo "$story_info" | cut -d'|' -f1)
    local story_title
    story_title=$(echo "$story_info" | cut -d'|' -f2)
    local story_description
    story_description=$(echo "$story_info" | cut -d'|' -f3)

    # Route to agent-runtime if using non-Claude provider (LLM-013)
    if [ "$PRIMARY_PROVIDER" != "claude" ]; then
        log_info "Using provider: $PRIMARY_PROVIDER (non-Claude)"
        run_iteration_with_agent_runtime "$iteration" "$story_id" "$story_title" "$story_description"
        return $?
    fi

    log_iteration "$iteration" "Working on: $story_id - $story_title"

    # Log current phase if not default implementation
    if [ -n "$CURRENT_PHASE" ] && [ "$CURRENT_PHASE" != "implementation" ]; then
        log_info "Current phase: $CURRENT_PHASE (phase-aware agent selection active)"
    fi

    # Start execution logging
    if $EXECUTION_LOGGING_ENABLED; then
        # Build context with iteration info, agents, phase, and provider
        local exec_context
        exec_context=$(cat << EOF
{
  "iteration": $iteration,
  "max_iterations": $MAX_ITERATIONS,
  "agents_enabled": $AGENTS_ENABLED,
  "current_phase": "$CURRENT_PHASE",
  "provider": "$PRIMARY_PROVIDER",
  "project": "$(get_project_name)",
  "branch": "$(get_branch_from_prd)"
}
EOF
)
        log_execution_start "$story_id" "$story_title" "$exec_context"
    fi

    # Get full story text for agent selection
    local story_text
    story_text=$(get_story_text "$story_id")

    # Build prompt with agent expertise
    local full_prompt
    full_prompt=$(build_iteration_prompt "$story_id" "$story_text")

    log_debug "Prompt size: $(echo "$full_prompt" | wc -c | tr -d ' ') chars"

    # Log the Claude invocation action
    if $EXECUTION_LOGGING_ENABLED; then
        local prompt_size
        prompt_size=$(echo "$full_prompt" | wc -c | tr -d ' ')
        log_action "Claude" "{\"prompt_size\": $prompt_size, \"mode\": \"print\"}" "started" ""
    fi

    # Run Claude Code with the prompt
    if $VERBOSE; then
        output=$(echo "$full_prompt" | claude --print --dangerously-skip-permissions 2>&1) || exit_code=$?
    else
        output=$(echo "$full_prompt" | claude --print --dangerously-skip-permissions 2>&1) || exit_code=$?
    fi

    # Check for completion signal
    if echo "$output" | grep -q "$COMPLETION_SIGNAL"; then
        # Log successful completion
        if $EXECUTION_LOGGING_ENABLED; then
            log_execution_end "success" "" "$exit_code"
        fi
        return 0  # All stories complete
    fi

    # Check if story completed (by checking if passes is now true)
    local story_passes
    story_passes=$(jq -r ".userStories[] | select(.id == \"$story_id\") | .passes" "$PRD_FILE" 2>/dev/null || echo "false")

    if [ "$story_passes" = "true" ]; then
        # Story completed successfully
        log_success "Story $story_id completed"

        # Run review panel if enabled (LLM-007)
        if $REVIEW_ENABLED; then
            local review_cycle=1
            local review_passed=false

            while [ $review_cycle -le $MAX_REVIEW_CYCLES ] && ! $review_passed; do
                if [ $review_cycle -gt 1 ]; then
                    log_info "Review-fix cycle $review_cycle/$MAX_REVIEW_CYCLES"
                fi

                # Run review
                local review_result
                local review_exit_code=0
                review_result=$(run_review_panel "$story_id" "$story_title") || review_exit_code=$?

                if [ $review_exit_code -eq 0 ]; then
                    # Review passed
                    review_passed=true
                    log_success "Review passed on cycle $review_cycle"

                    # Log review results to execution log
                    if $EXECUTION_LOGGING_ENABLED && [ -n "$review_result" ]; then
                        log_action "ReviewPanel" "$review_result" "success" ""
                    fi
                elif [ $review_exit_code -eq 2 ]; then
                    # Review failed, needs fixes
                    if [ $review_cycle -lt $MAX_REVIEW_CYCLES ]; then
                        log_warn "Review failed, requesting fixes (cycle $review_cycle/$MAX_REVIEW_CYCLES)"

                        # Extract issues for fix prompt
                        local issues_summary
                        issues_summary=$(echo "$review_result" | jq -r '.reviews[].issues[].description' 2>/dev/null | head -10 | paste -sd "," - || echo "Review identified issues")

                        # Build fix prompt
                        local fix_prompt
                        fix_prompt="The previous implementation was reviewed by multiple LLMs and identified issues:

$issues_summary

Please address these review comments and fix the identified issues. Make sure all acceptance criteria are still met."

                        # Run another iteration with fix prompt
                        local fix_output
                        local fix_exit_code=0
                        fix_output=$(echo "$fix_prompt" | claude --print --dangerously-skip-permissions 2>&1) || fix_exit_code=$?

                        # Increment review cycle
                        ((review_cycle++))
                    else
                        log_warn "Maximum review cycles reached, proceeding despite review failures"
                        review_passed=true  # Force pass to avoid infinite loop

                        # Log review failure
                        if $EXECUTION_LOGGING_ENABLED && [ -n "$review_result" ]; then
                            log_action "ReviewPanel" "$review_result" "failure" "Maximum cycles reached"
                        fi
                    fi
                else
                    # Review panel error
                    log_warn "Review panel error, skipping review"
                    review_passed=true  # Skip review on error
                    break
                fi
            done
        fi

        # Log successful execution
        if $EXECUTION_LOGGING_ENABLED; then
            log_execution_end "success" "" "$exit_code"
        fi

        # Check if all stories complete
        local remaining
        remaining=$(get_incomplete_stories_count)
        if [ "$remaining" -eq 0 ]; then
            return 0  # All stories complete
        fi
    fi

    # Check for errors
    if [ $exit_code -ne 0 ]; then
        log_warn "Iteration $iteration exited with code $exit_code"

        # Log failed execution
        if $EXECUTION_LOGGING_ENABLED; then
            # Extract error message from output (last few lines often contain error)
            local error_msg
            error_msg=$(echo "$output" | tail -10 | head -5 | tr '\n' ' ' | cut -c1-500)
            log_execution_end "failure" "$error_msg" "$exit_code"
        fi
    else
        # Story not complete but no error - still in progress
        if $EXECUTION_LOGGING_ENABLED; then
            log_execution_end "in_progress" "" "$exit_code"
        fi
    fi

    return 1  # More work to do
}

# =============================================================================
# PRD Completion Functions (for new prds/active/* structure)
# =============================================================================

# Update MANIFEST.yaml when all stories are complete
update_manifest_on_completion() {
    # Only applicable if we're using the new PRD structure with PRD_DIR
    if [ -z "$PRD_DIR" ]; then
        log_debug "Not using new PRD structure, skipping MANIFEST.yaml update"
        return 0
    fi

    local manifest_file="$PRD_DIR/MANIFEST.yaml"
    if [ ! -f "$manifest_file" ]; then
        log_warn "MANIFEST.yaml not found at $manifest_file"
        return 1
    fi

    # Use Python to update the MANIFEST.yaml (handles YAML properly)
    python3 << EOF
import sys
try:
    import yaml
except ImportError:
    print("PyYAML not installed, skipping MANIFEST.yaml update", file=sys.stderr)
    sys.exit(0)

from datetime import datetime, timezone
import json

manifest_file = "$manifest_file"
prd_file = "$PRD_FILE"

# Load manifest
with open(manifest_file, 'r') as f:
    manifest = yaml.safe_load(f)

# Load prd.json to get story counts
with open(prd_file, 'r') as f:
    prd_data = json.load(f)

stories = prd_data.get('userStories', [])
total = len(stories)
completed = sum(1 for s in stories if s.get('passes', False))

# Update manifest
timestamp = datetime.now(timezone.utc).strftime('%Y-%m-%dT%H:%M:%SZ')
manifest['status'] = 'completed'
manifest['updated_at'] = timestamp
manifest['completed_at'] = timestamp
manifest['story_count'] = total
manifest['completed_stories'] = completed

# Save manifest
with open(manifest_file, 'w') as f:
    yaml.dump(manifest, f, default_flow_style=False, allow_unicode=True, sort_keys=False)

print(f"Updated MANIFEST.yaml: status=completed, stories={completed}/{total}")
EOF

    local exit_code=$?
    if [ $exit_code -eq 0 ]; then
        log_success "Updated MANIFEST.yaml to status=completed"
        return 0
    else
        log_warn "Failed to update MANIFEST.yaml"
        return 1
    fi
}

# Move PRD to prds/completed/ on successful completion
move_prd_to_completed() {
    # Only applicable if we're using the new PRD structure with PRD_DIR
    if [ -z "$PRD_DIR" ]; then
        log_debug "Not using new PRD structure, skipping PRD move"
        return 0
    fi

    # Check if PRD_DIR is in prds/active/
    local prds_active_dir="${SCRIPT_DIR}/prds/active"
    if [[ "$PRD_DIR" != "$prds_active_dir"* ]]; then
        log_debug "PRD is not in prds/active/, skipping move"
        return 0
    fi

    local prd_name
    prd_name=$(basename "$PRD_DIR")
    local completed_dir="${SCRIPT_DIR}/prds/completed/$prd_name"

    # Check if target already exists
    if [ -d "$completed_dir" ]; then
        log_warn "Completed directory already exists: $completed_dir"
        log_warn "PRD not moved. Manual intervention may be required."
        return 1
    fi

    # Create prds/completed/ if it doesn't exist
    mkdir -p "${SCRIPT_DIR}/prds/completed"

    # Move the PRD directory
    log_info "Moving PRD to prds/completed/..."
    if mv "$PRD_DIR" "$completed_dir"; then
        log_success "Moved PRD to: $completed_dir"

        # Update PRD_DIR and PRD_FILE to reflect new location
        PRD_DIR="$completed_dir"
        PRD_FILE="$completed_dir/prd.json"
        PROGRESS_FILE="$completed_dir/progress.txt"

        # Log audit entry using prd-manager if available
        local prd_manager="${SCRIPT_DIR}/lib/prd-manager.py"
        if [ -f "$prd_manager" ]; then
            # Get PRD ID from manifest
            local prd_id
            prd_id=$(grep -E '^id:' "$completed_dir/MANIFEST.yaml" 2>/dev/null | head -1 | cut -d':' -f2 | tr -d ' ')
            if [ -n "$prd_id" ]; then
                # Log completion using prd-manager's audit function
                python3 "$prd_manager" audit --json 2>/dev/null | head -1 >/dev/null || true
            fi
        fi

        return 0
    else
        log_error "Failed to move PRD to completed/"
        return 1
    fi
}

# Handle PRD completion (update manifest and move)
handle_prd_completion() {
    log_info "Handling PRD completion..."

    # Update MANIFEST.yaml
    update_manifest_on_completion

    # Move PRD to completed directory
    move_prd_to_completed

    # Update PRD index if indexer is available
    local indexer="${SCRIPT_DIR}/lib/prd-indexer.py"
    if [ -f "$indexer" ]; then
        log_info "Updating PRD index..."
        python3 "$indexer" rebuild 2>/dev/null >/dev/null || log_debug "Index rebuild skipped"
    fi

    return 0
}

print_summary() {
    local total
    local complete
    local incomplete

    total=$(get_total_stories_count)
    incomplete=$(get_incomplete_stories_count)
    complete=$((total - incomplete))

    echo ""
    echo "═══════════════════════════════════════════════════════════════"
    echo "                      CLAUDE-LOOP SUMMARY"
    echo "═══════════════════════════════════════════════════════════════"
    echo ""
    echo "  Stories: $complete/$total complete"
    echo ""

    if [ "$incomplete" -eq 0 ]; then
        echo -e "  Status: ${GREEN}ALL STORIES COMPLETE${NC}"
    else
        echo -e "  Status: ${YELLOW}$incomplete stories remaining${NC}"
    fi

    if $AGENTS_ENABLED; then
        echo ""
        echo -e "  Agents: ${MAGENTA}Enabled${NC} (max $MAX_AGENTS_PER_ITERATION per story)"
    fi

    if $EXPERIENCE_AUGMENTATION_ENABLED; then
        echo -e "  Experience: ${CYAN}Enabled${NC} (helpful_rate > ${MIN_HELPFUL_RATE}, max ${MAX_EXPERIENCES})"
    fi

    if $UNITY_MODE; then
        echo -e "  Unity:  ${CYAN}Enabled${NC} (Quest 3 XR mode)"
    fi

    if $RESUME_MODE; then
        echo -e "  Resume: ${GREEN}Enabled${NC} (will check for checkpoints)"
    fi

    # Display execution logging stats if available
    if $EXECUTION_LOGGING_ENABLED && [ -f "$EXECUTION_LOG_FILE" ]; then
        local exec_count
        exec_count=$(get_execution_count)
        echo ""
        echo -e "  Execution Log: ${CYAN}$exec_count entries${NC}"
    fi

    echo ""
    echo "  Files:"
    echo "    - prd.json:     Task state (check passes: true/false)"
    echo "    - progress.txt: Iteration learnings"
    echo "    - AGENTS.md:    Discovered patterns"
    if $EXECUTION_LOGGING_ENABLED; then
        echo "    - .claude-loop/execution_log.jsonl: Execution logs"
    fi
    echo ""
    echo "═══════════════════════════════════════════════════════════════"
}

# ============================================================================
# Main Script
# ============================================================================

main() {
    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -m|--max-iterations)
                MAX_ITERATIONS="$2"
                shift 2
                ;;
            -p|--prd)
                # Resolve PRD path (supports prds/active/* structure)
                resolve_prd_path "$2"
                shift 2
                ;;
            -a|--agents-dir)
                AGENTS_DIR="$2"
                shift 2
                ;;
            -d|--delay)
                DELAY_SECONDS="$2"
                shift 2
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            --no-agents)
                AGENTS_ENABLED=false
                shift
                ;;
            --no-experience)
                EXPERIENCE_AUGMENTATION_ENABLED=false
                shift
                ;;
            --no-dashboard)
                PROGRESS_DASHBOARD_ENABLED=false
                shift
                ;;
            --compact-dashboard)
                DASHBOARD_COMPACT=true
                shift
                ;;
            --max-agents)
                MAX_AGENTS_PER_ITERATION="$2"
                shift 2
                ;;
            --agent-tiers)
                ENABLED_TIERS="$2"
                shift 2
                ;;
            --unity)
                UNITY_MODE=true
                shift
                ;;
            --resume)
                RESUME_MODE=true
                shift
                ;;
            --resume-from)
                RESUME_MODE=true
                RESUME_FROM_SESSION="$2"
                shift 2
                ;;
            --list-sessions)
                # Source session state and list sessions
                if [ -f "$SESSION_STATE_SCRIPT" ]; then
                    source "$SESSION_STATE_SCRIPT"
                    list_sessions "text"
                    exit 0
                else
                    log_error "Session state script not found: $SESSION_STATE_SCRIPT"
                    exit 1
                fi
                ;;
            --no-session)
                SESSION_STATE_ENABLED=false
                shift
                ;;
            --list-improvements)
                IMPROVEMENT_MODE="list"
                shift
                ;;
            --review-improvement)
                IMPROVEMENT_MODE="review"
                IMPROVEMENT_TARGET="$2"
                shift 2
                ;;
            --approve-improvement)
                IMPROVEMENT_MODE="approve"
                IMPROVEMENT_TARGET="$2"
                shift 2
                ;;
            --reject-improvement)
                IMPROVEMENT_MODE="reject"
                IMPROVEMENT_TARGET="$2"
                shift 2
                ;;
            --validate-improvement)
                IMPROVEMENT_MODE="validate"
                IMPROVEMENT_TARGET="$2"
                shift 2
                ;;
            --execute-improvement)
                IMPROVEMENT_MODE="execute"
                IMPROVEMENT_TARGET="$2"
                shift 2
                ;;
            --improvement-history)
                IMPROVEMENT_MODE="history"
                shift
                ;;
            --rollback-improvement)
                IMPROVEMENT_MODE="rollback"
                IMPROVEMENT_TARGET="$2"
                shift 2
                ;;
            --notes)
                IMPROVEMENT_NOTES="$2"
                shift 2
                ;;
            --reason)
                IMPROVEMENT_REASON="$2"
                shift 2
                ;;
            --validate)
                IMPROVEMENT_VALIDATE=true
                shift
                ;;
            --force)
                IMPROVEMENT_FORCE=true
                shift
                ;;
            --dry-run)
                IMPROVEMENT_DRY_RUN=true
                shift
                ;;
            --start-daemon)
                DAEMON_MODE="start"
                shift
                ;;
            --stop-daemon)
                DAEMON_MODE="stop"
                shift
                ;;
            --daemon-status)
                DAEMON_MODE="status"
                shift
                ;;
            --validate-classifier)
                # Run classification accuracy tests
                log_info "Running classification accuracy validation..."
                if [ -f ".venv/bin/pytest" ]; then
                    .venv/bin/pytest tests/test_failure_classification.py -v -s
                    exit $?
                elif command -v pytest &> /dev/null; then
                    pytest tests/test_failure_classification.py -v -s
                    exit $?
                else
                    log_error "pytest not found. Install with: pip install pytest"
                    exit 1
                fi
                ;;
            --autonomous)
                AUTONOMOUS_MODE=true
                shift
                ;;
            --disable-autonomous)
                DISABLE_AUTONOMOUS=true
                shift
                ;;
            --autonomous-status)
                # Show autonomous gate status
                if [ -f "$AUTONOMOUS_GATE" ]; then
                    python3 "$AUTONOMOUS_GATE" status
                    exit $?
                else
                    log_error "Autonomous gate not found: $AUTONOMOUS_GATE"
                    exit 1
                fi
                ;;
            --enable-review)
                REVIEW_ENABLED=true
                shift
                ;;
            --reviewers)
                REVIEW_PROVIDERS="$2"
                shift 2
                ;;
            --review-threshold)
                REVIEW_THRESHOLD="$2"
                shift 2
                ;;
            --max-review-cycles)
                MAX_REVIEW_CYCLES="$2"
                shift 2
                ;;
            --provider)
                PRIMARY_PROVIDER="$2"
                shift 2
                ;;
            --model)
                PROVIDER_MODELS="$2"
                shift 2
                ;;
            -h|--help)
                show_help
                exit 0
                ;;
            -*)
                log_error "Unknown option: $1"
                show_help
                exit 1
                ;;
            *)
                # Positional argument: treat as feature description (INV-008)
                FEATURE_DESCRIPTION="$1"
                AUTO_GENERATE_PRD=true
                shift
                ;;
        esac
    done

    # Handle autonomous mode commands
    if $DISABLE_AUTONOMOUS; then
        if [ -f "$AUTONOMOUS_GATE" ]; then
            log_info "Disabling autonomous mode..."
            python3 "$AUTONOMOUS_GATE" disable
            exit $?
        else
            log_error "Autonomous gate not found: $AUTONOMOUS_GATE"
            exit 1
        fi
    fi

    # Handle daemon mode first (exits if in daemon mode)
    # Pass --autonomous flag if enabled
    if [ -n "$DAEMON_MODE" ] && $AUTONOMOUS_MODE; then
        export DAEMON_AUTONOMOUS_MODE=true
    fi
    run_daemon_mode || true

    # Handle improvement management mode first (exits if in improvement mode)
    run_improvement_mode || true

    echo ""
    echo "═══════════════════════════════════════════════════════════════"
    echo "             CLAUDE-LOOP - Autonomous Feature Builder"
    echo "═══════════════════════════════════════════════════════════════"
    echo ""

    # Pre-flight checks
    log_info "Running pre-flight checks..."
    check_dependencies
    check_git_repo

    # Handle single-command entry point (INV-008)
    # If a feature description was provided, auto-generate PRD
    if $AUTO_GENERATE_PRD && [ -n "$FEATURE_DESCRIPTION" ]; then
        log_info "Single-command entry point detected (INV-008)"
        generate_prd_from_description "$FEATURE_DESCRIPTION"
    fi

    # If PRD_FILE is default (./prd.json) and doesn't exist, try auto-detection
    if [ "$PRD_FILE" = "./prd.json" ] && [ ! -f "$PRD_FILE" ]; then
        log_info "Default prd.json not found, checking prds/active/..."
        if ! auto_detect_active_prd; then
            # Auto-detection failed, let check_prd_exists show the error
            :
        fi
    fi

    check_prd_exists
    check_prompt_exists
    check_agents_dir
    check_execution_logger
    check_prompt_augmenter
    check_session_state

    # Get branch from PRD and handle archiving
    local target_branch
    target_branch=$(get_branch_from_prd)
    archive_previous_run "$target_branch"

    # Ensure we're on the correct branch
    ensure_correct_branch "$target_branch"

    # Initialize state files
    initialize_progress_file
    initialize_agents_file

    # Display initial status
    local project_name
    project_name=$(get_project_name)
    local total_stories
    total_stories=$(get_total_stories_count)
    local incomplete_stories
    incomplete_stories=$(get_incomplete_stories_count)

    # Display auto-detection summary for all runs (INV-011)
    # Shows complexity, track, phases, and quality gates
    display_auto_detection_summary

    log_info "Project: $project_name"
    log_info "Branch: $target_branch"
    log_info "Stories: $incomplete_stories incomplete out of $total_stories total"
    log_info "Max iterations: $MAX_ITERATIONS"

    # Display provider information (LLM-013)
    log_info "Primary Provider: $PRIMARY_PROVIDER"
    if [ "$PRIMARY_PROVIDER" != "claude" ]; then
        log_warn "═══════════════════════════════════════════════════════════════"
        log_warn "WARNING: Using non-Claude provider ($PRIMARY_PROVIDER)"
        log_warn "Non-Claude providers have reduced capabilities:"
        log_warn "  - Limited tool availability (only read_file, write_file, run_bash, git_command)"
        log_warn "  - No access to Claude Code's advanced features"
        log_warn "  - May have lower success rates for complex tasks"
        log_warn "  - Recommended for testing and experimentation only"
        log_warn "═══════════════════════════════════════════════════════════════"
        if [ -n "$PROVIDER_MODELS" ]; then
            log_info "Model Override: $PROVIDER_MODELS"
        fi
    fi

    if $AGENTS_ENABLED; then
        log_agent "Agents: Enabled (tiers: $ENABLED_TIERS, max: $MAX_AGENTS_PER_ITERATION)"
    fi
    if $UNITY_MODE; then
        log_info "Unity Mode: Enabled (Quest 3 XR development)"
        if [ -f "$UNITY_ORCHESTRATOR" ]; then
            log_info "Unity Orchestrator: $UNITY_ORCHESTRATOR"
        else
            log_warn "Unity Orchestrator not found: $UNITY_ORCHESTRATOR"
        fi
    fi
    echo ""

    # Check if already complete
    if [ "$incomplete_stories" -eq 0 ]; then
        log_success "All stories already complete!"
        # Handle PRD completion (update MANIFEST.yaml, move to completed/)
        handle_prd_completion
        # Cleanup checkpoints on successful completion
        local workflow_id
        workflow_id=$(get_workflow_id)
        cleanup_checkpoints "$workflow_id" false
        # Finish session state
        finish_session
        print_summary
        exit 0
    fi

    # Initialize or resume session state (INV-007)
    local resume_iteration=0
    if $SESSION_STATE_ENABLED; then
        resume_iteration=$(init_or_resume_session)
        if [ "$resume_iteration" -gt 0 ]; then
            log_info "Session will continue from iteration $resume_iteration"
        else
            echo -e "${CYAN}[INFO]${NC} You can close this. Progress auto-saves."
        fi
    fi

    # Check for resume from checkpoint (legacy)
    local resume_step_index=0
    if $RESUME_MODE && [ "$resume_iteration" -eq 0 ]; then
        resume_step_index=$(check_resume_from_checkpoint) || resume_step_index=0
    fi

    # Run solutioning generator for complex projects (Level >= 3) (INV-011)
    # Generates architecture.md and ADR templates before implementation
    if [ "$resume_iteration" -eq 0 ] && [ "$resume_step_index" -eq 0 ]; then
        # Only run solutioning for fresh starts (not resumes)
        if should_run_solutioning; then
            run_solutioning_generator
            display_detected_adrs
        fi
    fi

    # Main iteration loop - start from resume point if available
    local iteration=1
    if [ "$resume_iteration" -gt 0 ]; then
        iteration=$((resume_iteration + 1))  # Continue from next iteration
    elif [ "$resume_step_index" -gt 0 ]; then
        iteration=$((resume_step_index + 1))
    fi
    local all_complete=false
    local workflow_id
    workflow_id=$(get_workflow_id)

    # Display initial progress dashboard
    display_progress_dashboard

    while [ $iteration -le $MAX_ITERATIONS ]; do
        # Check remaining stories
        incomplete_stories=$(get_incomplete_stories_count)
        if [ "$incomplete_stories" -eq 0 ]; then
            all_complete=true
            break
        fi

        log_iteration "$iteration" "Stories remaining: $incomplete_stories"

        # Get current story for checkpoint
        local story_info
        story_info=$(get_next_story)
        local story_id
        story_id=$(echo "$story_info" | cut -d'|' -f1)

        # Display progress with current story running
        display_progress_compact "$story_id"

        # Run the iteration
        if run_iteration $iteration; then
            all_complete=true
            log_success "All stories complete!"

            # Handle PRD completion (update MANIFEST.yaml, move to completed/)
            handle_prd_completion

            # Cleanup checkpoints on successful completion
            cleanup_checkpoints "$workflow_id" false

            # Finish session state (INV-007)
            finish_session

            break
        fi

        # Save checkpoint after each successful iteration (legacy)
        local context
        context=$(printf '{"story_id": "%s", "iteration": %d, "incomplete_stories": %d}' "$story_id" "$iteration" "$incomplete_stories")
        save_checkpoint "$workflow_id" "$story_id" "$iteration" "$context" > /dev/null

        # Save session state after each iteration (INV-007)
        save_story_progress "$story_id" "$iteration" "$CURRENT_PHASE"

        # Display updated progress after iteration
        display_progress_compact

        # Delay between iterations
        if [ $iteration -lt $MAX_ITERATIONS ]; then
            log_info "Waiting ${DELAY_SECONDS}s before next iteration..."
            sleep "$DELAY_SECONDS"
        fi

        ((iteration++))
    done

    # Final summary with full dashboard
    display_progress_dashboard
    print_summary

    # Display completion summary (INV-010) for successful runs
    if $all_complete; then
        display_completion_summary
        log_success "Feature implementation complete!"
        exit 0
    else
        log_warn "Max iterations ($MAX_ITERATIONS) reached. Some stories may be incomplete."
        log_info "You can continue by running: ./claude-loop.sh --resume"
        exit 1
    fi
}

# Run main function
main "$@"
